export { createDerivers, createHashInput, };
let complexTypes = new Set(['object', 'function']);
let primitives = new Set([Number, String, Boolean, BigInt, null, undefined]);
function createDerivers() {
    const HashInput = createHashInput();
    function provable(typeObj, options) {
        let objectKeys = typeof typeObj === 'object' && typeObj !== null
            ? Object.keys(typeObj)
            : [];
        if (!primitives.has(typeObj) && !complexTypes.has(typeof typeObj)) {
            throw Error(`provable: unsupported type "${typeObj}"`);
        }
        function sizeInFields(typeObj) {
            if (primitives.has(typeObj))
                return 0;
            if (!complexTypes.has(typeof typeObj))
                throw Error(`provable: unsupported type "${typeObj}"`);
            if (Array.isArray(typeObj))
                return typeObj.map(sizeInFields).reduce((a, b) => a + b, 0);
            if ('sizeInFields' in typeObj)
                return typeObj.sizeInFields();
            return Object.values(typeObj)
                .map(sizeInFields)
                .reduce((a, b) => a + b, 0);
        }
        function toFields(typeObj, obj, isToplevel = false) {
            if (primitives.has(typeObj))
                return [];
            if (!complexTypes.has(typeof typeObj))
                throw Error(`provable: unsupported type "${typeObj}"`);
            if (Array.isArray(typeObj))
                return typeObj.map((t, i) => toFields(t, obj[i])).flat();
            if ('toFields' in typeObj)
                return typeObj.toFields(obj);
            return (isToplevel ? objectKeys : Object.keys(typeObj))
                .map((k) => toFields(typeObj[k], obj[k]))
                .flat();
        }
        function toAuxiliary(typeObj, obj, isToplevel = false) {
            if (typeObj === Number)
                return [obj ?? 0];
            if (typeObj === String)
                return [obj ?? ''];
            if (typeObj === Boolean)
                return [obj ?? false];
            if (typeObj === BigInt)
                return [obj ?? 0n];
            if (typeObj === undefined || typeObj === null)
                return [];
            if (!complexTypes.has(typeof typeObj))
                throw Error(`provable: unsupported type "${typeObj}"`);
            if (Array.isArray(typeObj))
                return typeObj.map((t, i) => toAuxiliary(t, obj?.[i]));
            if ('toAuxiliary' in typeObj)
                return typeObj.toAuxiliary(obj);
            return (isToplevel ? objectKeys : Object.keys(typeObj)).map((k) => toAuxiliary(typeObj[k], obj?.[k]));
        }
        function fromFields(typeObj, fields, aux = [], isToplevel = false) {
            if (typeObj === Number ||
                typeObj === String ||
                typeObj === Boolean ||
                typeObj === BigInt)
                return aux[0];
            if (typeObj === undefined || typeObj === null)
                return typeObj;
            if (!complexTypes.has(typeof typeObj))
                throw Error(`provable: unsupported type "${typeObj}"`);
            if (Array.isArray(typeObj)) {
                let array = [];
                let i = 0;
                let offset = 0;
                for (let subObj of typeObj) {
                    let size = sizeInFields(subObj);
                    array.push(fromFields(subObj, fields.slice(offset, offset + size), aux[i]));
                    offset += size;
                    i++;
                }
                return array;
            }
            if ('fromFields' in typeObj)
                return typeObj.fromFields(fields, aux);
            let keys = isToplevel ? objectKeys : Object.keys(typeObj);
            let values = fromFields(keys.map((k) => typeObj[k]), fields, aux);
            return Object.fromEntries(keys.map((k, i) => [k, values[i]]));
        }
        function check(typeObj, obj, isToplevel = false) {
            if (primitives.has(typeObj))
                return;
            if (!complexTypes.has(typeof typeObj))
                throw Error(`provable: unsupported type "${typeObj}"`);
            if (Array.isArray(typeObj))
                return typeObj.forEach((t, i) => check(t, obj[i]));
            if ('check' in typeObj)
                return typeObj.check(obj);
            return (isToplevel ? objectKeys : Object.keys(typeObj)).forEach((k) => check(typeObj[k], obj[k]));
        }
        const toValue = createMap('toValue');
        const fromValue = createMap('fromValue');
        let { empty, fromJSON, toJSON, toInput } = signable(typeObj);
        if (options?.isPure === true) {
            return {
                sizeInFields: () => sizeInFields(typeObj),
                toFields: (obj) => toFields(typeObj, obj, true),
                toAuxiliary: () => [],
                fromFields: (fields) => fromFields(typeObj, fields, [], true),
                check: (obj) => check(typeObj, obj, true),
                toValue(x) {
                    return toValue(typeObj, x);
                },
                fromValue(v) {
                    return fromValue(typeObj, v);
                },
                toInput: (obj) => toInput(obj),
                toJSON: (obj) => toJSON(obj),
                fromJSON: (json) => fromJSON(json),
                empty: () => empty(),
            };
        }
        return {
            sizeInFields: () => sizeInFields(typeObj),
            toFields: (obj) => toFields(typeObj, obj, true),
            toAuxiliary: (obj) => toAuxiliary(typeObj, obj, true),
            fromFields: (fields, aux) => fromFields(typeObj, fields, aux, true),
            check: (obj) => check(typeObj, obj, true),
            toValue(x) {
                return toValue(typeObj, x);
            },
            fromValue(v) {
                return fromValue(typeObj, v);
            },
            toInput: (obj) => toInput(obj),
            toJSON: (obj) => toJSON(obj),
            fromJSON: (json) => fromJSON(json),
            empty: () => empty(),
        };
    }
    function signable(typeObj) {
        let objectKeys = typeof typeObj === 'object' && typeObj !== null
            ? Object.keys(typeObj)
            : [];
        let primitives = new Set([
            Number,
            String,
            Boolean,
            BigInt,
            null,
            undefined,
        ]);
        if (!primitives.has(typeObj) && !complexTypes.has(typeof typeObj)) {
            throw Error(`provable: unsupported type "${typeObj}"`);
        }
        function toInput(typeObj, obj, isToplevel = false) {
            if (primitives.has(typeObj))
                return {};
            if (!complexTypes.has(typeof typeObj))
                throw Error(`provable: unsupported type "${typeObj}"`);
            if (Array.isArray(typeObj)) {
                return typeObj
                    .map((t, i) => toInput(t, obj[i]))
                    .reduce(HashInput.append, HashInput.empty);
            }
            if ('toInput' in typeObj)
                return typeObj.toInput(obj);
            if ('toFields' in typeObj) {
                return { fields: typeObj.toFields(obj) };
            }
            return (isToplevel ? objectKeys : Object.keys(typeObj))
                .map((k) => toInput(typeObj[k], obj[k]))
                .reduce(HashInput.append, HashInput.empty);
        }
        function toJSON(typeObj, obj, isToplevel = false) {
            if (typeObj === BigInt)
                return obj.toString();
            if (typeObj === String || typeObj === Number || typeObj === Boolean)
                return obj;
            if (typeObj === undefined || typeObj === null)
                return null;
            if (!complexTypes.has(typeof typeObj))
                throw Error(`provable: unsupported type "${typeObj}"`);
            if (Array.isArray(typeObj))
                return typeObj.map((t, i) => toJSON(t, obj[i]));
            if ('toJSON' in typeObj)
                return typeObj.toJSON(obj);
            return Object.fromEntries((isToplevel ? objectKeys : Object.keys(typeObj)).map((k) => [
                k,
                toJSON(typeObj[k], obj[k]),
            ]));
        }
        function fromJSON(typeObj, json, isToplevel = false) {
            if (typeObj === BigInt)
                return BigInt(json);
            if (typeObj === String || typeObj === Number || typeObj === Boolean)
                return json;
            if (typeObj === null || typeObj === undefined)
                return undefined;
            if (!complexTypes.has(typeof typeObj))
                throw Error(`provable: unsupported type "${typeObj}"`);
            if (Array.isArray(typeObj))
                return typeObj.map((t, i) => fromJSON(t, json[i]));
            if ('fromJSON' in typeObj)
                return typeObj.fromJSON(json);
            let keys = isToplevel ? objectKeys : Object.keys(typeObj);
            let values = fromJSON(keys.map((k) => typeObj[k]), keys.map((k) => json[k]));
            return Object.fromEntries(keys.map((k, i) => [k, values[i]]));
        }
        function empty(typeObj) {
            if (typeObj === Number)
                return 0;
            if (typeObj === String)
                return '';
            if (typeObj === Boolean)
                return false;
            if (typeObj === BigInt)
                return 0n;
            if (typeObj === null || typeObj === undefined)
                return typeObj;
            if (!complexTypes.has(typeof typeObj))
                throw Error(`provable: unsupported type "${typeObj}"`);
            if (Array.isArray(typeObj))
                return typeObj.map(empty);
            if ('empty' in typeObj)
                return typeObj.empty();
            return Object.fromEntries(Object.keys(typeObj).map((k) => [k, empty(typeObj[k])]));
        }
        return {
            toInput: (obj) => toInput(typeObj, obj, true),
            toJSON: (obj) => toJSON(typeObj, obj, true),
            fromJSON: (json) => fromJSON(typeObj, json, true),
            empty: () => empty(typeObj),
        };
    }
    return { provable, signable };
}
function createMap(name) {
    function map(typeObj, obj) {
        if (primitives.has(typeObj))
            return obj;
        if (!complexTypes.has(typeof typeObj))
            throw Error(`provable: unsupported type "${typeObj}"`);
        if (Array.isArray(typeObj))
            return typeObj.map((t, i) => map(t, obj[i]));
        if (name in typeObj)
            return typeObj[name](obj);
        return Object.fromEntries(Object.keys(typeObj).map((k) => [k, map(typeObj[k], obj[k])]));
    }
    return map;
}
function createHashInput() {
    return {
        get empty() {
            return {};
        },
        append(input1, input2) {
            return {
                fields: (input1.fields ?? []).concat(input2.fields ?? []),
                packed: (input1.packed ?? []).concat(input2.packed ?? []),
            };
        },
    };
}
//# sourceMappingURL=provable-generic.js.map