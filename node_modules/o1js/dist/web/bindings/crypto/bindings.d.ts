import type * as wasmNamespace from '../compiled/node_bindings/plonk_wasm.cjs';
import { fieldsFromRustFlat, fieldsToRustFlat } from './bindings/conversion-base.js';
export { getRustConversion, RustConversion, Wasm };
type Wasm = typeof wasmNamespace;
declare function createRustConversion(wasm: Wasm): {
    fp: {
        proofToRust([, public_evals, proof]: import("./bindings/kimchi-types.js").ProofWithPublic): wasmNamespace.WasmFqProverProof | wasmNamespace.WasmFpProverProof;
        proofFromRust(wasmProof: wasmNamespace.WasmFqProverProof | wasmNamespace.WasmFpProverProof): import("./bindings/kimchi-types.js").ProofWithPublic;
        runtimeTablesToRust([, ...tables]: import("../../lib/ml/base.js").MlArray<import("./bindings/kimchi-types.js").RuntimeTable>): Uint32Array;
        runtimeTableCfgsToRust([, ...tableCfgs]: import("../../lib/ml/base.js").MlArray<import("./bindings/kimchi-types.js").RuntimeTableCfg>): Uint32Array;
        lookupTablesToRust([, ...tables]: import("../../lib/ml/base.js").MlArray<import("./bindings/kimchi-types.js").LookupTable>): Uint32Array;
        oraclesToRust(oracles: import("./bindings/kimchi-types.js").Oracles): wasmNamespace.WasmFqOracles | wasmNamespace.WasmFpOracles;
        oraclesFromRust(oracles: wasmNamespace.WasmFqOracles | wasmNamespace.WasmFpOracles): import("./bindings/kimchi-types.js").Oracles;
        shiftsToRust([, ...shifts]: import("../../lib/ml/base.js").MlArray<import("./bindings/field.js").Field>): wasmNamespace.WasmFpShifts | wasmNamespace.WasmFqShifts;
        shiftsFromRust(s: wasmNamespace.WasmFpShifts | wasmNamespace.WasmFqShifts): import("../../lib/ml/base.js").MlArray<import("./bindings/field.js").Field>;
        verifierIndexToRust(vk: import("./bindings/kimchi-types.js").VerifierIndex): wasmNamespace.WasmFqPlonkVerifierIndex | wasmNamespace.WasmFpPlonkVerifierIndex;
        verifierIndexFromRust(vk: wasmNamespace.WasmFqPlonkVerifierIndex | wasmNamespace.WasmFpPlonkVerifierIndex): import("./bindings/kimchi-types.js").VerifierIndex;
        wireToRust([, row, col]: import("./bindings/kimchi-types.js").Wire): wasmNamespace.Wire;
        vectorToRust: typeof fieldsToRustFlat;
        vectorFromRust: typeof fieldsFromRustFlat;
        gateToRust(gate: import("./bindings/kimchi-types.js").Gate): wasmNamespace.WasmFpGate | wasmNamespace.WasmFqGate;
        gateFromRust(wasmGate: wasmNamespace.WasmFpGate | wasmNamespace.WasmFqGate): never;
        pointToRust(point: import("./bindings/curve.js").OrInfinity): import("./bindings/conversion-base.js").WasmAffine;
        pointFromRust: typeof import("./bindings/conversion-base.js").affineFromRust;
        pointsToRust([, ...points]: import("../../lib/ml/base.js").MlArray<import("./bindings/curve.js").OrInfinity>): Uint32Array;
        pointsFromRust(points: Uint32Array): import("../../lib/ml/base.js").MlArray<import("./bindings/curve.js").OrInfinity>;
        polyCommToRust(polyComm: import("./bindings/kimchi-types.js").PolyComm): wasmNamespace.WasmFpPolyComm | wasmNamespace.WasmFqPolyComm;
        polyCommFromRust(polyComm: wasmNamespace.WasmFpPolyComm | wasmNamespace.WasmFqPolyComm): import("./bindings/kimchi-types.js").PolyComm;
        polyCommsToRust([, ...comms]: import("../../lib/ml/base.js").MlArray<import("./bindings/kimchi-types.js").PolyComm>): Uint32Array;
        polyCommsFromRust(rustComms: Uint32Array): import("../../lib/ml/base.js").MlArray<import("./bindings/kimchi-types.js").PolyComm>;
    };
    fq: {
        proofToRust([, public_evals, proof]: import("./bindings/kimchi-types.js").ProofWithPublic): wasmNamespace.WasmFqProverProof | wasmNamespace.WasmFpProverProof;
        proofFromRust(wasmProof: wasmNamespace.WasmFqProverProof | wasmNamespace.WasmFpProverProof): import("./bindings/kimchi-types.js").ProofWithPublic;
        runtimeTablesToRust([, ...tables]: import("../../lib/ml/base.js").MlArray<import("./bindings/kimchi-types.js").RuntimeTable>): Uint32Array;
        runtimeTableCfgsToRust([, ...tableCfgs]: import("../../lib/ml/base.js").MlArray<import("./bindings/kimchi-types.js").RuntimeTableCfg>): Uint32Array;
        lookupTablesToRust([, ...tables]: import("../../lib/ml/base.js").MlArray<import("./bindings/kimchi-types.js").LookupTable>): Uint32Array;
        oraclesToRust(oracles: import("./bindings/kimchi-types.js").Oracles): wasmNamespace.WasmFqOracles | wasmNamespace.WasmFpOracles;
        oraclesFromRust(oracles: wasmNamespace.WasmFqOracles | wasmNamespace.WasmFpOracles): import("./bindings/kimchi-types.js").Oracles;
        shiftsToRust([, ...shifts]: import("../../lib/ml/base.js").MlArray<import("./bindings/field.js").Field>): wasmNamespace.WasmFpShifts | wasmNamespace.WasmFqShifts;
        shiftsFromRust(s: wasmNamespace.WasmFpShifts | wasmNamespace.WasmFqShifts): import("../../lib/ml/base.js").MlArray<import("./bindings/field.js").Field>;
        verifierIndexToRust(vk: import("./bindings/kimchi-types.js").VerifierIndex): wasmNamespace.WasmFqPlonkVerifierIndex | wasmNamespace.WasmFpPlonkVerifierIndex;
        verifierIndexFromRust(vk: wasmNamespace.WasmFqPlonkVerifierIndex | wasmNamespace.WasmFpPlonkVerifierIndex): import("./bindings/kimchi-types.js").VerifierIndex;
        wireToRust([, row, col]: import("./bindings/kimchi-types.js").Wire): wasmNamespace.Wire;
        vectorToRust: typeof fieldsToRustFlat;
        vectorFromRust: typeof fieldsFromRustFlat;
        gateToRust(gate: import("./bindings/kimchi-types.js").Gate): wasmNamespace.WasmFpGate | wasmNamespace.WasmFqGate;
        gateFromRust(wasmGate: wasmNamespace.WasmFpGate | wasmNamespace.WasmFqGate): never;
        pointToRust(point: import("./bindings/curve.js").OrInfinity): import("./bindings/conversion-base.js").WasmAffine;
        pointFromRust: typeof import("./bindings/conversion-base.js").affineFromRust;
        pointsToRust([, ...points]: import("../../lib/ml/base.js").MlArray<import("./bindings/curve.js").OrInfinity>): Uint32Array;
        pointsFromRust(points: Uint32Array): import("../../lib/ml/base.js").MlArray<import("./bindings/curve.js").OrInfinity>;
        polyCommToRust(polyComm: import("./bindings/kimchi-types.js").PolyComm): wasmNamespace.WasmFpPolyComm | wasmNamespace.WasmFqPolyComm;
        polyCommFromRust(polyComm: wasmNamespace.WasmFpPolyComm | wasmNamespace.WasmFqPolyComm): import("./bindings/kimchi-types.js").PolyComm;
        polyCommsToRust([, ...comms]: import("../../lib/ml/base.js").MlArray<import("./bindings/kimchi-types.js").PolyComm>): Uint32Array;
        polyCommsFromRust(rustComms: Uint32Array): import("../../lib/ml/base.js").MlArray<import("./bindings/kimchi-types.js").PolyComm>;
    };
    fieldsToRustFlat: typeof fieldsToRustFlat;
    fieldsFromRustFlat: typeof fieldsFromRustFlat;
    wireToRust: ([, row, col]: import("./bindings/kimchi-types.js").Wire) => wasmNamespace.Wire;
    mapMlArrayToRustVector: <TMl, TRust extends {}>([, ...array]: import("../../lib/ml/base.js").MlArray<TMl>, map: (x: TMl) => TRust) => Uint32Array;
};
type RustConversion = ReturnType<typeof createRustConversion>;
declare function getRustConversion(wasm: Wasm): {
    fp: {
        proofToRust([, public_evals, proof]: import("./bindings/kimchi-types.js").ProofWithPublic): wasmNamespace.WasmFqProverProof | wasmNamespace.WasmFpProverProof;
        proofFromRust(wasmProof: wasmNamespace.WasmFqProverProof | wasmNamespace.WasmFpProverProof): import("./bindings/kimchi-types.js").ProofWithPublic;
        runtimeTablesToRust([, ...tables]: import("../../lib/ml/base.js").MlArray<import("./bindings/kimchi-types.js").RuntimeTable>): Uint32Array;
        runtimeTableCfgsToRust([, ...tableCfgs]: import("../../lib/ml/base.js").MlArray<import("./bindings/kimchi-types.js").RuntimeTableCfg>): Uint32Array;
        lookupTablesToRust([, ...tables]: import("../../lib/ml/base.js").MlArray<import("./bindings/kimchi-types.js").LookupTable>): Uint32Array;
        oraclesToRust(oracles: import("./bindings/kimchi-types.js").Oracles): wasmNamespace.WasmFqOracles | wasmNamespace.WasmFpOracles;
        oraclesFromRust(oracles: wasmNamespace.WasmFqOracles | wasmNamespace.WasmFpOracles): import("./bindings/kimchi-types.js").Oracles;
        shiftsToRust([, ...shifts]: import("../../lib/ml/base.js").MlArray<import("./bindings/field.js").Field>): wasmNamespace.WasmFpShifts | wasmNamespace.WasmFqShifts;
        shiftsFromRust(s: wasmNamespace.WasmFpShifts | wasmNamespace.WasmFqShifts): import("../../lib/ml/base.js").MlArray<import("./bindings/field.js").Field>;
        verifierIndexToRust(vk: import("./bindings/kimchi-types.js").VerifierIndex): wasmNamespace.WasmFqPlonkVerifierIndex | wasmNamespace.WasmFpPlonkVerifierIndex;
        verifierIndexFromRust(vk: wasmNamespace.WasmFqPlonkVerifierIndex | wasmNamespace.WasmFpPlonkVerifierIndex): import("./bindings/kimchi-types.js").VerifierIndex;
        wireToRust([, row, col]: import("./bindings/kimchi-types.js").Wire): wasmNamespace.Wire;
        vectorToRust: typeof fieldsToRustFlat;
        vectorFromRust: typeof fieldsFromRustFlat;
        gateToRust(gate: import("./bindings/kimchi-types.js").Gate): wasmNamespace.WasmFpGate | wasmNamespace.WasmFqGate;
        gateFromRust(wasmGate: wasmNamespace.WasmFpGate | wasmNamespace.WasmFqGate): never;
        pointToRust(point: import("./bindings/curve.js").OrInfinity): import("./bindings/conversion-base.js").WasmAffine;
        pointFromRust: typeof import("./bindings/conversion-base.js").affineFromRust;
        pointsToRust([, ...points]: import("../../lib/ml/base.js").MlArray<import("./bindings/curve.js").OrInfinity>): Uint32Array;
        pointsFromRust(points: Uint32Array): import("../../lib/ml/base.js").MlArray<import("./bindings/curve.js").OrInfinity>;
        polyCommToRust(polyComm: import("./bindings/kimchi-types.js").PolyComm): wasmNamespace.WasmFpPolyComm | wasmNamespace.WasmFqPolyComm;
        polyCommFromRust(polyComm: wasmNamespace.WasmFpPolyComm | wasmNamespace.WasmFqPolyComm): import("./bindings/kimchi-types.js").PolyComm;
        polyCommsToRust([, ...comms]: import("../../lib/ml/base.js").MlArray<import("./bindings/kimchi-types.js").PolyComm>): Uint32Array;
        polyCommsFromRust(rustComms: Uint32Array): import("../../lib/ml/base.js").MlArray<import("./bindings/kimchi-types.js").PolyComm>;
    };
    fq: {
        proofToRust([, public_evals, proof]: import("./bindings/kimchi-types.js").ProofWithPublic): wasmNamespace.WasmFqProverProof | wasmNamespace.WasmFpProverProof;
        proofFromRust(wasmProof: wasmNamespace.WasmFqProverProof | wasmNamespace.WasmFpProverProof): import("./bindings/kimchi-types.js").ProofWithPublic;
        runtimeTablesToRust([, ...tables]: import("../../lib/ml/base.js").MlArray<import("./bindings/kimchi-types.js").RuntimeTable>): Uint32Array;
        runtimeTableCfgsToRust([, ...tableCfgs]: import("../../lib/ml/base.js").MlArray<import("./bindings/kimchi-types.js").RuntimeTableCfg>): Uint32Array;
        lookupTablesToRust([, ...tables]: import("../../lib/ml/base.js").MlArray<import("./bindings/kimchi-types.js").LookupTable>): Uint32Array;
        oraclesToRust(oracles: import("./bindings/kimchi-types.js").Oracles): wasmNamespace.WasmFqOracles | wasmNamespace.WasmFpOracles;
        oraclesFromRust(oracles: wasmNamespace.WasmFqOracles | wasmNamespace.WasmFpOracles): import("./bindings/kimchi-types.js").Oracles;
        shiftsToRust([, ...shifts]: import("../../lib/ml/base.js").MlArray<import("./bindings/field.js").Field>): wasmNamespace.WasmFpShifts | wasmNamespace.WasmFqShifts;
        shiftsFromRust(s: wasmNamespace.WasmFpShifts | wasmNamespace.WasmFqShifts): import("../../lib/ml/base.js").MlArray<import("./bindings/field.js").Field>;
        verifierIndexToRust(vk: import("./bindings/kimchi-types.js").VerifierIndex): wasmNamespace.WasmFqPlonkVerifierIndex | wasmNamespace.WasmFpPlonkVerifierIndex;
        verifierIndexFromRust(vk: wasmNamespace.WasmFqPlonkVerifierIndex | wasmNamespace.WasmFpPlonkVerifierIndex): import("./bindings/kimchi-types.js").VerifierIndex;
        wireToRust([, row, col]: import("./bindings/kimchi-types.js").Wire): wasmNamespace.Wire;
        vectorToRust: typeof fieldsToRustFlat;
        vectorFromRust: typeof fieldsFromRustFlat;
        gateToRust(gate: import("./bindings/kimchi-types.js").Gate): wasmNamespace.WasmFpGate | wasmNamespace.WasmFqGate;
        gateFromRust(wasmGate: wasmNamespace.WasmFpGate | wasmNamespace.WasmFqGate): never;
        pointToRust(point: import("./bindings/curve.js").OrInfinity): import("./bindings/conversion-base.js").WasmAffine;
        pointFromRust: typeof import("./bindings/conversion-base.js").affineFromRust;
        pointsToRust([, ...points]: import("../../lib/ml/base.js").MlArray<import("./bindings/curve.js").OrInfinity>): Uint32Array;
        pointsFromRust(points: Uint32Array): import("../../lib/ml/base.js").MlArray<import("./bindings/curve.js").OrInfinity>;
        polyCommToRust(polyComm: import("./bindings/kimchi-types.js").PolyComm): wasmNamespace.WasmFpPolyComm | wasmNamespace.WasmFqPolyComm;
        polyCommFromRust(polyComm: wasmNamespace.WasmFpPolyComm | wasmNamespace.WasmFqPolyComm): import("./bindings/kimchi-types.js").PolyComm;
        polyCommsToRust([, ...comms]: import("../../lib/ml/base.js").MlArray<import("./bindings/kimchi-types.js").PolyComm>): Uint32Array;
        polyCommsFromRust(rustComms: Uint32Array): import("../../lib/ml/base.js").MlArray<import("./bindings/kimchi-types.js").PolyComm>;
    };
    fieldsToRustFlat: typeof fieldsToRustFlat;
    fieldsFromRustFlat: typeof fieldsFromRustFlat;
    wireToRust: ([, row, col]: import("./bindings/kimchi-types.js").Wire) => wasmNamespace.Wire;
    mapMlArrayToRustVector: <TMl, TRust extends {}>([, ...array]: import("../../lib/ml/base.js").MlArray<TMl>, map: (x: TMl) => TRust) => Uint32Array;
};
