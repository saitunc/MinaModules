import { CurveParams } from '../../../bindings/crypto/elliptic-curve.js';
import { ProvablePureExtended } from '../types/struct.js';
import { FlexiblePoint, ForeignCurve } from './foreign-curve.js';
import { AlmostForeignField } from '../foreign-field.js';
import { Field3 } from '../gadgets/foreign-field.js';
import { Bytes } from '../wrapped-classes.js';
export { createEcdsa, EcdsaSignature };
type FlexibleSignature = EcdsaSignature | {
    r: AlmostForeignField | Field3 | bigint | number;
    s: AlmostForeignField | Field3 | bigint | number;
};
declare class EcdsaSignature {
    r: AlmostForeignField;
    s: AlmostForeignField;
    /**
     * Create a new {@link EcdsaSignature} from an object containing the scalars r and s.
     * @param signature
     */
    constructor(signature: {
        r: AlmostForeignField | Field3 | bigint | number;
        s: AlmostForeignField | Field3 | bigint | number;
    });
    /**
     * Coerce the input to a {@link EcdsaSignature}.
     */
    static from(signature: FlexibleSignature): EcdsaSignature;
    /**
     * Create an {@link EcdsaSignature} from a raw 130-char hex string as used in
     * [Ethereum transactions](https://ethereum.org/en/developers/docs/transactions/#typed-transaction-envelope).
     */
    static fromHex(rawSignature: string): EcdsaSignature;
    /**
     * Convert this signature to an object with bigint fields.
     */
    toBigInt(): {
        r: bigint;
        s: bigint;
    };
    /**
     * Verify the ECDSA signature given the message (an array of bytes) and public key (a {@link Curve} point).
     *
     * **Important:** This method returns a {@link Bool} which indicates whether the signature is valid.
     * So, to actually prove validity of a signature, you need to assert that the result is true.
     *
     * @throws if one of the signature scalars is zero or if the public key is not on the curve.
     *
     * @example
     * ```ts
     * // create classes for your curve
     * class Secp256k1 extends createForeignCurve(Crypto.CurveParams.Secp256k1) {}
     * class Scalar extends Secp256k1.Scalar {}
     * class Ecdsa extends createEcdsa(Secp256k1) {}
     *
     * let message = 'my message';
     * let messageBytes = new TextEncoder().encode(message);
     *
     * // outside provable code: create inputs
     * let privateKey = Scalar.random();
     * let publicKey = Secp256k1.generator.scale(privateKey);
     * let signature = Ecdsa.sign(messageBytes, privateKey.toBigInt());
     *
     * // ...
     * // in provable code: create input witnesses (or use method inputs, or constants)
     * let pk = Provable.witness(Secp256k1.provable, () => publicKey);
     * let msg = Provable.witness(Provable.Array(Field, 9), () => messageBytes.map(Field));
     * let sig = Provable.witness(Ecdsa.provable, () => signature);
     *
     * // verify signature
     * let isValid = sig.verify(msg, pk);
     * isValid.assertTrue('signature verifies');
     * ```
     */
    verify(message: Bytes, publicKey: FlexiblePoint): import("../bool.js").Bool;
    /**
     * Verify the ECDSA signature given the message hash (a {@link Scalar}) and public key (a {@link Curve} point).
     *
     * This is a building block of {@link EcdsaSignature.verify}, where the input message is also hashed.
     * In contrast, this method just takes the message hash (a curve scalar) as input, giving you flexibility in
     * choosing the hashing algorithm.
     */
    verifySignedHash(msgHash: AlmostForeignField | bigint, publicKey: FlexiblePoint): import("../bool.js").Bool;
    /**
     * Create an {@link EcdsaSignature} by signing a message with a private key.
     *
     * Note: This method is not provable, and only takes JS bigints as input.
     */
    static sign(message: (bigint | number)[] | Uint8Array, privateKey: bigint): EcdsaSignature;
    /**
     * Create an {@link EcdsaSignature} by signing a message hash with a private key.
     *
     * This is a building block of {@link EcdsaSignature.sign}, where the input message is also hashed.
     * In contrast, this method just takes the message hash (a curve scalar) as input, giving you flexibility in
     * choosing the hashing algorithm.
     *
     * Note: This method is not provable, and only takes JS bigints as input.
     */
    static signHash(msgHash: bigint, privateKey: bigint): EcdsaSignature;
    static check(signature: EcdsaSignature): void;
    get Constructor(): typeof EcdsaSignature;
    static _Curve?: typeof ForeignCurve;
    static _provable?: ProvablePureExtended<EcdsaSignature, {
        r: string;
        s: string;
    }>;
    /**
     * The {@link ForeignCurve} on which the ECDSA signature is defined.
     */
    static get Curve(): typeof ForeignCurve;
    /**
     * `Provable<EcdsaSignature>`
     */
    static get provable(): ProvablePureExtended<EcdsaSignature, {
        r: string;
        s: string;
    }>;
}
/**
 * Create a class {@link EcdsaSignature} for verifying ECDSA signatures on the given curve.
 */
declare function createEcdsa(curve: CurveParams | typeof ForeignCurve): typeof EcdsaSignature;
