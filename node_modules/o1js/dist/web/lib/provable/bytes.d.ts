import type { ProvablePureExtended } from './types/struct.js';
import { UInt8 } from './int.js';
export { Bytes };
export { createBytes, FlexibleBytes };
type FlexibleBytes = Bytes | (UInt8 | bigint | number)[] | Uint8Array;
/**
 * A provable type representing an array of bytes.
 */
declare class Bytes {
    bytes: UInt8[];
    constructor(bytes: UInt8[]);
    /**
     * Coerce the input to {@link Bytes}.
     *
     * Inputs smaller than `this.size` are padded with zero bytes.
     */
    static from(data: (UInt8 | bigint | number)[] | Uint8Array | Bytes): Bytes;
    toBytes(): Uint8Array;
    toFields(): import("./field.js").Field[];
    /**
     * Create {@link Bytes} from a string.
     *
     * Inputs smaller than `this.size` are padded with zero bytes.
     */
    static fromString(s: string): Bytes;
    /**
     * Create random {@link Bytes} using secure builtin randomness.
     */
    static random(): Bytes;
    /**
     * Create {@link Bytes} from a hex string.
     *
     * Inputs smaller than `this.size` are padded with zero bytes.
     */
    static fromHex(xs: string): Bytes;
    /**
     * Convert {@link Bytes} to a hex string.
     */
    toHex(): string;
    static _size?: number;
    static _provable?: ProvablePureExtended<Bytes, {
        bytes: {
            value: string;
        }[];
    }>;
    /**
     * The size of the {@link Bytes}.
     */
    static get size(): number;
    get length(): number;
    /**
     * `Provable<Bytes>`
     */
    static get provable(): ProvablePureExtended<Bytes, {
        bytes: {
            value: string;
        }[];
    }>;
}
declare function createBytes(size: number): typeof Bytes;
