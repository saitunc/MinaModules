import { Pickles, Gate, GateType } from '../../snarky.js';
import { Field, Bool } from '../provable/wrapped.js';
import { FlexibleProvable, FlexibleProvablePure, InferProvable, ProvablePureExtended } from '../provable/types/struct.js';
import { Provable } from '../provable/provable.js';
import { FieldConst } from '../provable/core/fieldvar.js';
import { Cache } from './cache.js';
import { ProvablePure } from '../provable/types/provable-intf.js';
export { ProofBase, Proof, DynamicProof, SelfProof, JsonProof, ZkProgram, verify, Empty, Undefined, Void, VerificationKey, };
export { CompiledTag, sortMethodArguments, getPreviousProofsForProver, MethodInterface, picklesRuleFromFunction, compileProgram, analyzeMethod, emptyValue, emptyWitness, synthesizeMethodArguments, methodArgumentsToConstant, methodArgumentTypesAndValues, isAsFields, Prover, dummyBase64Proof, };
type Undefined = undefined;
declare const Undefined: ProvablePureExtended<undefined, undefined, null>;
type Empty = Undefined;
declare const Empty: ProvablePureExtended<undefined, undefined, null>;
type Void = undefined;
declare const Void: ProvablePureExtended<void, void, null>;
declare class ProofBase<Input, Output> {
    static publicInputType: FlexibleProvablePure<any>;
    static publicOutputType: FlexibleProvablePure<any>;
    static tag: () => {
        name: string;
    };
    publicInput: Input;
    publicOutput: Output;
    proof: Pickles.Proof;
    maxProofsVerified: 0 | 1 | 2;
    shouldVerify: import("../provable/bool.js").Bool;
    toJSON(): JsonProof;
    constructor({ proof, publicInput, publicOutput, maxProofsVerified, }: {
        proof: Pickles.Proof;
        publicInput: Input;
        publicOutput: Output;
        maxProofsVerified: 0 | 1 | 2;
    });
}
declare class Proof<Input, Output> extends ProofBase<Input, Output> {
    verify(): void;
    verifyIf(condition: Bool): void;
    static fromJSON<S extends Subclass<typeof Proof>>(this: S, { maxProofsVerified, proof: proofString, publicInput: publicInputJson, publicOutput: publicOutputJson, }: JsonProof): Promise<Proof<InferProvable<S['publicInputType']>, InferProvable<S['publicOutputType']>>>;
    /**
     * Dummy proof. This can be useful for ZkPrograms that handle the base case in the same
     * method as the inductive case, using a pattern like this:
     *
     * ```ts
     * method(proof: SelfProof<I, O>, isRecursive: Bool) {
     *   proof.verifyIf(isRecursive);
     *   // ...
     * }
     * ```
     *
     * To use such a method in the base case, you need a dummy proof:
     *
     * ```ts
     * let dummy = await MyProof.dummy(publicInput, publicOutput, 1);
     * await myProgram.myMethod(dummy, Bool(false));
     * ```
     *
     * **Note**: The types of `publicInput` and `publicOutput`, as well as the `maxProofsVerified` parameter,
     * must match your ZkProgram. `maxProofsVerified` is the maximum number of proofs that any of your methods take as arguments.
     */
    static dummy<Input, OutPut>(publicInput: Input, publicOutput: OutPut, maxProofsVerified: 0 | 1 | 2, domainLog2?: number): Promise<Proof<Input, OutPut>>;
}
/**
 * The `DynamicProof` class enables circuits to verify proofs using in-ciruit verfication keys.
 * This is opposed to the baked-in verification keys of the `Proof` class.
 *
 * In order to use this, a subclass of DynamicProof that specifies the public input and output types along with the maxProofsVerified number has to be created.
 *
 * ```ts
 * export class SideloadedProgramProof extends DynamicProof<MyStruct, Field> {
 *   static publicInputType = MyStruct;
 *   static publicOutputType = Field;
 *   static maxProofsVerified = 0 as const;
 * }
 * ```
 *
 * The `maxProofsVerified` constant is a product of the child circuit and indicates the maximum number that that circuit verifies itself.
 * If you are unsure about what that is for you, you should use `2`.
 *
 * Any `DynamicProof` subclass can be used as private input to ZkPrograms or SmartContracts along with a `VerificationKey` input.
 * ```ts
 * proof.verify(verificationKey)
 * ```
 *
 * NOTE: In the case of `DynamicProof`s, the circuit makes no assertions about the verificationKey used on its own.
 * This is the responsibility of the application developer and should always implement appropriate checks.
 * This pattern differs a lot from the usage of normal `Proof`, where the verification key is baked into the compiled circuit.
 * @see {@link src/examples/zkprogram/dynamic-keys-merkletree.ts} for an example of how this can be done using merkle trees
 *
 * Assertions generally only happen using the vk hash that is part of the `VerificationKey` struct along with the raw vk data as auxilary data.
 * When using verify() on a `DynamicProof`, Pickles makes sure that the verification key data matches the hash.
 * Therefore all manual assertions have to be made on the vk's hash and it can be assumed that the vk's data is checked to match the hash if it is used with verify().
 */
declare class DynamicProof<Input, Output> extends ProofBase<Input, Output> {
    static maxProofsVerified: 0 | 1 | 2;
    private static memoizedCounter;
    static tag(): {
        name: string;
    };
    usedVerificationKey?: VerificationKey;
    /**
     * Verifies this DynamicProof using a given verification key
     * @param vk The verification key this proof will be verified against
     */
    verify(vk: VerificationKey): void;
    verifyIf(vk: VerificationKey, condition: Bool): void;
    static fromJSON<S extends Subclass<typeof DynamicProof>>(this: S, { maxProofsVerified, proof: proofString, publicInput: publicInputJson, publicOutput: publicOutputJson, }: JsonProof): Promise<DynamicProof<InferProvable<S['publicInputType']>, InferProvable<S['publicOutputType']>>>;
    static dummy<S extends Subclass<typeof DynamicProof>>(this: S, publicInput: InferProvable<S['publicInputType']>, publicOutput: InferProvable<S['publicOutputType']>, maxProofsVerified: 0 | 1 | 2, domainLog2?: number): Promise<InstanceType<S>>;
    /**
     * Converts a Proof into a DynamicProof carrying over all relevant data.
     * This method can be used to convert a Proof computed by a ZkProgram
     * into a DynamicProof that is accepted in a circuit that accepts DynamicProofs
     */
    static fromProof<S extends Subclass<typeof DynamicProof>>(this: S, proof: Proof<InferProvable<S['publicInputType']>, InferProvable<S['publicOutputType']>>): InstanceType<S>;
}
declare function verify(proof: ProofBase<any, any> | JsonProof, verificationKey: string | VerificationKey): Promise<boolean>;
type JsonProof = {
    publicInput: string[];
    publicOutput: string[];
    maxProofsVerified: 0 | 1 | 2;
    proof: string;
};
type CompiledTag = unknown;
declare let CompiledTag: {
    get(tag: any): CompiledTag | undefined;
    store(tag: any, compiledTag: CompiledTag): void;
};
declare function ZkProgram<StatementType extends {
    publicInput?: FlexibleProvablePure<any>;
    publicOutput?: FlexibleProvablePure<any>;
}, Types extends {
    [I in string]: Tuple<PrivateInput>;
}>(config: StatementType & {
    name: string;
    methods: {
        [I in keyof Types]: Method<InferProvableOrUndefined<Get<StatementType, 'publicInput'>>, InferProvableOrVoid<Get<StatementType, 'publicOutput'>>, Types[I]>;
    };
    overrideWrapDomain?: 0 | 1 | 2;
}): {
    name: string;
    compile: (options?: {
        cache?: Cache;
        forceRecompile?: boolean;
    }) => Promise<{
        verificationKey: {
            data: string;
            hash: Field;
        };
    }>;
    verify: (proof: Proof<InferProvableOrUndefined<Get<StatementType, 'publicInput'>>, InferProvableOrVoid<Get<StatementType, 'publicOutput'>>>) => Promise<boolean>;
    digest: () => Promise<string>;
    analyzeMethods: () => Promise<{
        [I in keyof Types]: UnwrapPromise<ReturnType<typeof analyzeMethod>>;
    }>;
    publicInputType: ProvableOrUndefined<Get<StatementType, 'publicInput'>>;
    publicOutputType: ProvableOrVoid<Get<StatementType, 'publicOutput'>>;
    privateInputTypes: {
        [I in keyof Types]: Method<InferProvableOrUndefined<Get<StatementType, 'publicInput'>>, InferProvableOrVoid<Get<StatementType, 'publicOutput'>>, Types[I]>['privateInputs'];
    };
    rawMethods: {
        [I in keyof Types]: Method<InferProvableOrUndefined<Get<StatementType, 'publicInput'>>, InferProvableOrVoid<Get<StatementType, 'publicOutput'>>, Types[I]>['method'];
    };
} & {
    [I in keyof Types]: Prover<InferProvableOrUndefined<Get<StatementType, 'publicInput'>>, InferProvableOrVoid<Get<StatementType, 'publicOutput'>>, Types[I]>;
};
declare namespace ZkProgram {
    var Proof: <PublicInputType extends FlexibleProvablePure<any>, PublicOutputType extends FlexibleProvablePure<any>>(program: {
        name: string;
        publicInputType: PublicInputType;
        publicOutputType: PublicOutputType;
    }) => {
        new ({ proof, publicInput, publicOutput, maxProofsVerified, }: {
            proof: unknown;
            publicInput: InferProvable<PublicInputType>;
            publicOutput: InferProvable<PublicOutputType>;
            maxProofsVerified: 0 | 2 | 1;
        }): {
            verify(): void;
            verifyIf(condition: import("../provable/bool.js").Bool): void;
            publicInput: import("../../bindings/lib/provable-generic.js").InferProvable<PublicInputType, import("../provable/field.js").Field>;
            publicOutput: import("../../bindings/lib/provable-generic.js").InferProvable<PublicOutputType, import("../provable/field.js").Field>;
            proof: unknown;
            maxProofsVerified: 0 | 2 | 1;
            shouldVerify: import("../provable/bool.js").Bool;
            toJSON(): JsonProof;
        };
        publicInputType: PublicInputType;
        publicOutputType: PublicOutputType;
        tag: () => {
            name: string;
            publicInputType: PublicInputType;
            publicOutputType: PublicOutputType;
        };
        fromJSON<S extends Subclass<typeof import("./zkprogram.js").Proof>>(this: S, { maxProofsVerified, proof: proofString, publicInput: publicInputJson, publicOutput: publicOutputJson, }: JsonProof): Promise<Proof<InferProvable<S["publicInputType"]>, InferProvable<S["publicOutputType"]>>>;
        /**
         * Dummy proof. This can be useful for ZkPrograms that handle the base case in the same
         * method as the inductive case, using a pattern like this:
         *
         * ```ts
         * method(proof: SelfProof<I, O>, isRecursive: Bool) {
         *   proof.verifyIf(isRecursive);
         *   // ...
         * }
         * ```
         *
         * To use such a method in the base case, you need a dummy proof:
         *
         * ```ts
         * let dummy = await MyProof.dummy(publicInput, publicOutput, 1);
         * await myProgram.myMethod(dummy, Bool(false));
         * ```
         *
         * **Note**: The types of `publicInput` and `publicOutput`, as well as the `maxProofsVerified` parameter,
         * must match your ZkProgram. `maxProofsVerified` is the maximum number of proofs that any of your methods take as arguments.
         */
        dummy<Input, OutPut>(publicInput: Input, publicOutput: OutPut, maxProofsVerified: 0 | 2 | 1, domainLog2?: number): Promise<Proof<Input, OutPut>>;
    };
}
type ZkProgram<S extends {
    publicInput?: FlexibleProvablePure<any>;
    publicOutput?: FlexibleProvablePure<any>;
}, T extends {
    [I in string]: Tuple<PrivateInput>;
}> = ReturnType<typeof ZkProgram<S, T>>;
declare class SelfProof<PublicInput, PublicOutput> extends Proof<PublicInput, PublicOutput> {
}
declare const VerificationKey_base: (new (value: {
    data: string;
    hash: import("../provable/field.js").Field;
}) => {
    data: string;
    hash: import("../provable/field.js").Field;
}) & {
    _isStruct: true;
} & Provable<{
    data: string;
    hash: import("../provable/field.js").Field;
}, {
    data: string;
    hash: bigint;
}> & {
    fromValue: (value: {
        data: string;
        hash: import("../provable/field.js").Field;
    } | {
        data: string;
        hash: bigint;
    }) => {
        data: string;
        hash: import("../provable/field.js").Field;
    };
    toInput: (x: {
        data: string;
        hash: import("../provable/field.js").Field;
    }) => {
        fields?: import("../provable/field.js").Field[] | undefined;
        packed?: [import("../provable/field.js").Field, number][] | undefined;
    };
    toJSON: (x: {
        data: string;
        hash: import("../provable/field.js").Field;
    }) => string;
    fromJSON: (x: string) => {
        data: string;
        hash: import("../provable/field.js").Field;
    };
    empty: () => {
        data: string;
        hash: import("../provable/field.js").Field;
    };
};
declare class VerificationKey extends VerificationKey_base {
}
declare function sortMethodArguments(programName: string, methodName: string, privateInputs: unknown[], selfProof: Subclass<typeof Proof>): MethodInterface;
declare function isAsFields(type: unknown): type is Provable<unknown> & ObjectConstructor;
declare function getPreviousProofsForProver(methodArgs: any[], { allArgs }: MethodInterface): unknown[];
type MethodInterface = {
    methodName: string;
    witnessArgs: Provable<unknown>[];
    proofArgs: Subclass<typeof ProofBase>[];
    allArgs: {
        type: 'witness' | 'proof';
        index: number;
    }[];
    returnType?: Provable<any>;
};
declare function compileProgram({ publicInputType, publicOutputType, methodIntfs, methods, gates, proofSystemTag, cache, forceRecompile, overrideWrapDomain, }: {
    publicInputType: ProvablePure<any>;
    publicOutputType: ProvablePure<any>;
    methodIntfs: MethodInterface[];
    methods: ((...args: any) => unknown)[];
    gates: Gate[][];
    proofSystemTag: {
        name: string;
    };
    cache: Cache;
    forceRecompile: boolean;
    overrideWrapDomain?: 0 | 1 | 2;
}): Promise<{
    verificationKey: {
        data: string;
        hash: import("../provable/field.js").Field;
    };
    provers: Pickles.Prover[];
    verify: (statement: Pickles.Statement<FieldConst>, proof: Pickles.Proof) => Promise<boolean>;
    tag: unknown;
}>;
declare function analyzeMethod(publicInputType: ProvablePure<any>, methodIntf: MethodInterface, method: (...args: any) => unknown): Promise<{
    rows: number;
    digest: string;
    gates: Gate[];
    publicInputSize: number;
    print(): void;
    summary(): Partial<Record<GateType | "Total rows", number>>;
}>;
declare function picklesRuleFromFunction(publicInputType: ProvablePure<unknown>, publicOutputType: ProvablePure<unknown>, func: (...args: unknown[]) => unknown, proofSystemTag: {
    name: string;
}, { methodName, witnessArgs, proofArgs, allArgs }: MethodInterface, gates: Gate[]): Pickles.Rule;
declare function synthesizeMethodArguments({ allArgs, proofArgs, witnessArgs }: MethodInterface, asVariables?: boolean): unknown[];
declare function methodArgumentsToConstant({ allArgs, proofArgs, witnessArgs }: MethodInterface, args: any[]): any[];
type TypeAndValue<T> = {
    type: Provable<T>;
    value: T;
};
declare function methodArgumentTypesAndValues({ allArgs, proofArgs, witnessArgs }: MethodInterface, args: unknown[]): TypeAndValue<any>[];
declare function emptyValue<T>(type: FlexibleProvable<T>): T;
declare function emptyWitness<T>(type: FlexibleProvable<T>): T;
declare function dummyBase64Proof(): Promise<string>;
declare function Prover<ProverData>(): {
    run<Result>(witnesses: unknown[], proverData: ProverData, callback: () => Promise<Result>): Promise<Result>;
    getData(): ProverData;
};
type Infer<T> = T extends Subclass<typeof ProofBase> ? InstanceType<T> : InferProvable<T>;
type Tuple<T> = [T, ...T[]] | [];
type TupleToInstances<T> = {
    [I in keyof T]: Infer<T[I]>;
} & any[];
type Subclass<Class extends new (...args: any) => any> = (new (...args: any) => InstanceType<Class>) & {
    [K in keyof Class]: Class[K];
} & {
    prototype: InstanceType<Class>;
};
type PrivateInput = Provable<any> | Subclass<typeof ProofBase>;
type Method<PublicInput, PublicOutput, Args extends Tuple<PrivateInput>> = PublicInput extends undefined ? {
    privateInputs: Args;
    method(...args: TupleToInstances<Args>): Promise<PublicOutput>;
} : {
    privateInputs: Args;
    method(publicInput: PublicInput, ...args: TupleToInstances<Args>): Promise<PublicOutput>;
};
type Prover<PublicInput, PublicOutput, Args extends Tuple<PrivateInput>> = PublicInput extends undefined ? (...args: TupleToInstances<Args>) => Promise<Proof<PublicInput, PublicOutput>> : (publicInput: PublicInput, ...args: TupleToInstances<Args>) => Promise<Proof<PublicInput, PublicOutput>>;
type ProvableOrUndefined<A> = A extends undefined ? typeof Undefined : A;
type ProvableOrVoid<A> = A extends undefined ? typeof Void : A;
type InferProvableOrUndefined<A> = A extends undefined ? undefined : InferProvable<A>;
type InferProvableOrVoid<A> = A extends undefined ? void : InferProvable<A>;
type UnwrapPromise<P> = P extends Promise<infer T> ? T : never;
/**
 * helper to get property type from an object, in place of `T[Key]`
 *
 * assume `T extends { Key?: Something }`.
 * if we use `Get<T, Key>` instead of `T[Key]`, we allow `T` to be inferred _without_ the `Key` key,
 * and thus retain the precise type of `T` during inference
 */
type Get<T, Key extends string> = T extends {
    [K in Key]: infer Value;
} ? Value : undefined;
